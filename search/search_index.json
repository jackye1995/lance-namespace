{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Lance Namespace Specification is an open specification on top of the storage-based Lance data format to standardize access to a collection of Lance tables (a.k.a. Lance datasets). It describes how a metadata service like Apache Hive MetaStore (HMS), Apache Gravitino, Unity Catalog, etc. should store and use Lance tables, as well as how ML/AI tools and analytics compute engines should integrate with Lance tables.</p>"},{"location":"dev-guide/","title":"Development Guide","text":""},{"location":"dev-guide/#repository-structure","title":"Repository structure","text":"Component Language Path Description spec docs/src/spec Lance Namespace Specification Rust Reqwest Client Rust rust/lance-namespace-reqwest-client Generated Rust reqwest client for Lance REST Namespace Python UrlLib3 Client Python python/lance_namespace_urllib3_client Generated Python urllib3 client for Lance REST Namespace Java Apache Client Java java/lance-namespace-apache-client Generated Java Apache HTTP client for Lance REST Namespace Java Springboot Server Java java/lance-namespace-springboot-server Generated Java SpringBoot server for Lance REST Namespace Java Lance Namespace Core Java java/lance-namespace-core Lance Namespace Java Core SDK Java Lance Namespace Adapter Java java/lance-namespace-adaptor Lance Namespace adapter server implementation"},{"location":"dev-guide/#install-openapi-generator","title":"Install OpenAPI Generator","text":"<p>We use OpenAPI Generator to generate various clients and servers for the namespace specification. We recommend installing the tool through pip for consistent experience across platforms. First time setup of virtual environment and installation:</p> <pre><code>python3 -m venv .env\nsource .env/bin/activate\npip install -r requirements.txt\n</code></pre>"},{"location":"dev-guide/#install-poetry-for-python","title":"Install Poetry for Python","text":"<p>If you want to build the entire project, or develop python specifically, you need to install poetry. To quickly install it in your virtual environment:</p> <pre><code>pip install -r python/requirements.txt\n</code></pre>"},{"location":"dev-guide/#lint","title":"Lint","text":"<p>To ensure the OpenAPI definition is valid, you can use the lint command to check it.</p> <pre><code>make lint\n</code></pre>"},{"location":"dev-guide/#build","title":"Build","text":"<p>There are 3 commands that is available at top level as well as inside each language folder:</p> <ul> <li><code>make clean</code>: remove all codegen modules</li> <li><code>make gen</code>: codegen and lint all modules (depends on <code>clean</code>)</li> <li><code>make build</code>: build all modules (depends on <code>gen</code>)</li> </ul> <p>You can also run <code>make &lt;command&gt;-&lt;language&gt;</code> to only run the command in the specific language, for example:</p> <ul> <li><code>make gen-python</code>: codegen and lint all Python modules</li> <li><code>make build-rust</code>: build all Rust modules</li> </ul> <p>You can also run <code>make &lt;command&gt;-&lt;language&gt;-&lt;module&gt;</code> inside a language folder to run the command against a specific module, for example:</p> <ul> <li><code>make gen-rust-reqwest-client</code>: codegen and lint the Rust reqwest client module</li> <li><code>make build-java-springboot-server</code>: build the Java Spring Boot server module</li> </ul>"},{"location":"spec/spec/","title":"Lance Namespace Specification","text":"<p>Lance Namespace Specification is an open specification on top of the storage-based Lance data format to standardize access to a collection of Lance tables (a.k.a. Lance datasets). It describes how a metadata service like Apache Hive MetaStore (HMS), Apache Gravitino, Unity Catalog, etc. should store and use Lance tables, as well as how ML/AI tools and analytics compute engines (will together be called \"tools\" in this document) should integrate with Lance tables.</p>"},{"location":"spec/spec/#namespace-concepts","title":"Namespace Concepts","text":""},{"location":"spec/spec/#namespace-definition","title":"Namespace Definition","text":"<p>A Lance namespace is a centralized repository for discovering, organizing, and managing Lance tables. It can either contain a collection of tables, or a collection of Lance namespaces recursively. It is designed to encapsulates concepts including namespace, metastore, database, schema, etc. that frequently appear in other similar data systems to allow easy integration with any system of any type of object hierarchy.</p> <p>Here is an example layout of a Lance namespace:</p> <p></p>"},{"location":"spec/spec/#parent-child","title":"Parent &amp; Child","text":"<p>We use the term parent and child to describe relationship between 2 objects. If namespace A directly contains B, then A is the parent namespace of B, i.e. B is a child of A. For examples:</p> <ul> <li>Namespace <code>ns1</code> contains a child namespace <code>ns4</code>. i.e. <code>ns1</code> is the parent namespace of <code>ns4</code>.</li> <li>Namespace <code>ns2</code> contains a child table <code>t2</code>, i.e. <code>t2</code> belongs to parent namespace <code>ns2</code>.</li> </ul>"},{"location":"spec/spec/#root-namespace","title":"Root Namespace","text":"<p>A root namespace is a namespace that has no parent. The root namespace is assumed to always exist and is ready to be connected to by a tool to explore objects in the namespace. The lifecycle management (e.g. creation, deletion) of the root namespace is out of scope of this specification.</p>"},{"location":"spec/spec/#object-name","title":"Object Name","text":"<p>The name of an object is a string that uniquely identifies the object within the parent namespace it belongs to. The name of any object must be unique among all other objects that share the same parent namespace. For examples:</p> <ul> <li><code>cat2</code>, <code>cat3</code> and <code>cat4</code> are all unique names under the root namespace</li> <li><code>t3</code> and <code>t4</code> are both unique names under <code>cat4</code></li> </ul>"},{"location":"spec/spec/#object-identifier","title":"Object Identifier","text":"<p>The identifier of an object uniquely identifies the object within the root namespace it belongs to. The identifier of any object must be unique among all other objects that share the same root namespace.</p> <p>Based on the uniqueness property of an object name within its parent namespace, an object identifier is the list of object names starting from (not including) the root namespace to (including) the object itself. This is also called an list identifier. For examples:</p> <ul> <li>the list identifier of <code>cat5</code> is <code>[cat2, cat5]</code></li> <li>the list identifier of <code>t1</code> is <code>[cat2, cat5, t1]</code></li> </ul> <p>The dot (<code>.</code>) symbol is typically used as the delimiter to join all the names to form an string identifier, but other symbols could also be used if dot is used in the object name. For examples:</p> <ul> <li>the string identifier of <code>cat5</code> is <code>cat2.cat5</code></li> <li>the string identifier of <code>t1</code> is <code>cat2.cat5.t1</code></li> <li>the string identifier of <code>t3</code> is <code>cat4$t3</code> when using delimiter <code>$</code></li> </ul>"},{"location":"spec/spec/#name-and-identifier-for-root-namespace","title":"Name and Identifier for Root Namespace","text":"<p>The root namespace itself has no name or identifier. When represented in code, its name and string identifier is represented by an empty or null string, and its list identifier is represented by an empty or null list.</p> <p>The actual name and identifier of the root namespace is typically assigned by users through some configuration when used in a tool. For example, a root namespace can be called <code>cat1</code> in Ray, but called <code>cat2</code> in Apache Spark, and they are both configured to connect to the same root namespace.</p>"},{"location":"spec/spec/#namespace-operations","title":"Namespace Operations","text":"<p>The Lance Namespace Specification defines a list of operations that can be performed against any Lance namespace:</p> Operation ID Description ListOperations List the operations that are supported by this Lance namespace ListNamespaces List the names of child namespaces in the parent namespace, or root namespace if parent namespace is not specified NamespaceExists Check if a namespace exists DescribeNamespace Describe information of a namespace CreateNamespace Create a new namespace under a parent namespace, or root namespace if parent namespace is not specified AlterNamespace Alter information of a namespace DropNamespace Drop a namespace from its a parent namespace, or root namespace if parent namespace is not specified ListTables List the names of tables in a namespace TableExists Check if a table exists DescribeTable Describe information of a Lance table in the namespace CreateTable Create a new Lance table under a namespace RegisterTable Register an existing table at a given storage location to a namespace AlterTable Alter information of a Lance table DropTable Drop a table from its namespace DeregisterTable Deregister a table from its namespace, table content is kept unchanged in storage DescribeTransaction Describe information of a transaction AlterTransaction Alter information of a transaction"},{"location":"spec/spec/#operation-versioning","title":"Operation Versioning","text":"<p>There is no versioning concept within an operation. When backwards incompatible change is introduced, a new operation needs to be created, with a naming convention of <code>&lt;operationId&gt;V&lt;version&gt;</code>, for example <code>ListNamespacesV2</code>, <code>DescribeTableV3</code>, etc.</p>"},{"location":"spec/spec/#operation-request-and-response-schema","title":"Operation Request and Response Schema","text":"<p>Each operation has a request and response. The request and response schema is defined using JSON schema in the <code>components/schemas</code> section of rest.yaml.</p>"},{"location":"spec/spec/#namespace-implementations","title":"Namespace Implementations","text":"<p>A Lance Namespace Implementation is an implementation of the Lance namespace specification, more specifically:</p> <ol> <li>It satisfies all the Lance namespace definitions and concepts.</li> <li>It declares and implements a list of supported Lance namespace operations.</li> </ol>"},{"location":"spec/spec/#implementation-and-storage","title":"Implementation and Storage","text":"<p>Except for any storage-only implementation (e.g. Lance directory namespace), a Lance table exists both in the storage and the implementation. For example, a Lance table exists both in HMS and storage for the Lance HMS namespace. There are 2 possible ways to manage a Lance table under such setting. A Lance namespace implementation can choose to support one or both:</p>"},{"location":"spec/spec/#implementation-managed-table","title":"Implementation Managed Table","text":"<p>A implementation managed Lance table is a table that is fully managed by the Lance namespace implementation. The implementation must maintain information about the latest version of the Lance table. Any modifications to the table must happen through the implementation. If a user directly modifies the underlying table in the storage bypassing the implementation, the implementation must not reflect the changes in the table to the namespace users.</p> <p>This mode ensures the namespace service is aware of all activities in the table, and can thus fully enforce any governance and management features for the table.</p>"},{"location":"spec/spec/#storage-managed-table","title":"Storage Managed Table","text":"<p>A storage managed Lance table is a table that is fully managed by the storage with a metadata definition in the Lance namespace implementation. The implementation only contains information about the table directory location. It is expected that a tool finds the latest version of the Lance table based on the contents in the table directory according to the Lance format specification. A modification to the table can happen either directly against the storage, or happen as a request to the implementation, where the implementation is responsible for applying the corresponding change to the underlying storage according to the Lance format specification.</p> <p>This mode is more flexible for real world ML/AI workflows but the implementation loses full visibility and control over the actions performed against the table, so it will be harder to enforce any governance and management features for storage managed tables.</p>"},{"location":"spec/spec/#tool-integration-guidelines","title":"Tool Integration Guidelines","text":"<p>The following are guidelines for tools to integrate with Lance namespaces. Note that these are recommendations rather than hard requirements. The goal of these guidelines is to offer a consistent user experience across different tools.</p>"},{"location":"spec/spec/#configuring-the-implementation","title":"Configuring the Implementation","text":"<p>We recommend tools to offer a <code>impl</code> config key that allows user to configure the Namespace implementation. We recommend the following values for the natively supported implementations:</p> Implementation <code>impl</code> Value Directory dir Apache Hive MetaStore hive REST rest"},{"location":"spec/spec/#configuring-an-implementation-details","title":"Configuring an Implementation Details","text":"<p>We recommend tools to offer implementation specific configurations using the <code>impl</code> value as the config key prefix. For example, all config keys for the directory namespace should start with <code>dir.</code>, like <code>dir.path</code>.</p>"},{"location":"spec/impls/dir/","title":"Lance Directory Namespace","text":"<p>Lance directory namespace is a lightweight and simple 1-level Lance namespace that only contains a list of tables. People can easily get started with creating and using Lance tables directly on top of any local or remote storage system with a Lance directory namespace.</p> <p>A directory namespace maps to a directory on storage, we call such directory a namespace directory. A Lance table corresponds to a subdirectory in the namespace directory. We call such a subdirectories table directory. Consider the following example namespace directory layout:</p> <pre><code>.\n\u2514\u2500\u2500 /my/dir1/\n    \u251c\u2500\u2500 table1/\n    \u2502   \u251c\u2500\u2500 data/\n    \u2502   \u2502   \u251c\u2500\u2500 0aa36d91-8293-406b-958c-faf9e7547938.lance\n    \u2502   \u2502   \u2514\u2500\u2500 ed7af55d-b064-4442-bcb5-47b524e98d0e.lance\n    \u2502   \u251c\u2500\u2500 _versions/\n    \u2502   \u2502   \u2514\u2500\u2500 9223372036854775707.manifest\n    \u2502   \u251c\u2500\u2500 _indices/\n    \u2502   \u2502   \u2514\u2500\u2500 85814508-ed9a-41f2-b939-2050bb7a0ed5-fts/\n    \u2502   \u2502       \u2514\u2500\u2500 index.idx\n    \u2502   \u2514\u2500\u2500 _deletions/\n    \u2502       \u2514\u2500\u2500 75c69434-cde5-4c80-9fe1-e79a6d952fbf.bin\n    \u251c\u2500\u2500 table2\n    \u2514\u2500\u2500 table3\n</code></pre> <p>This describes a Lance directory namespace with the namespace directory at <code>/my/dir1/</code>. It contains tables <code>table1</code>, <code>table2</code>, <code>table3</code> sitting at table directories <code>/my/dirs/table1</code>, <code>/my/dirs/table2</code>, <code>/my/dirs/table3</code> respectively.</p>"},{"location":"spec/impls/dir/#directory-path","title":"Directory Path","text":"<p>There are 3 ways to specify a directory path:</p> <ol> <li>URI: a URI that follows the RFC 3986 specification, e.g. <code>s3://mu-bucket/prefix</code>.</li> <li>Absolute POSIX storage path: an absolute file path in a POSIX standard storage, e.g. <code>/my/dir</code>.</li> <li>Relative POSIX storage path: a relative file path in a POSIX standard storage, e.g. <code>my/dir2</code>, <code>./my/dir3</code>.    The absolute path of the directory should be based on the current directory of the running process.</li> </ol>"},{"location":"spec/impls/dir/#table-existence","title":"Table Existence","text":"<p>A table exists in a Lance directory namespace if a table directory of the specific name exists. This is true even if the directory is empty or the contents in the directory does not follow the Lance table format spec. For such cases, an operation that lists all tables in the directory should show the specific table, and an operation that checks if a table exists should return true. However, an operation that loads the Lance table metadata should fail with error indicating the content in the folder is not compliant with the Lance table format spec.</p>"},{"location":"spec/impls/hive/","title":"Lance HMS Namespace","text":"<p>Lance HMS Namespace directly integrates with HMS to offer a 2-level Lance namespace experience. The root namespace maps to the entire HMS, which has HMS databases as child namespaces.</p> <p>TODO: add more information after implementation is officially added.</p>"},{"location":"spec/impls/overview/","title":"Overview","text":""},{"location":"spec/impls/overview/#native-implementations","title":"Native Implementations","text":"<p>A native Lance namespace implementation is a Lance Namespace implementation  that is maintained in this <code>lance-namespace</code> repository. Any implementation that is outside the repository is considered as a third-party implementation.</p>"},{"location":"spec/impls/rest/","title":"Lance REST Namespace","text":"<p>In an enterprise environment, typically there is a requirement to store tables in a metadata service for more advanced governance features around access control, auditing, lineage tracking, etc. Lance REST Namespace is an OpenAPI protocol that enables reading, writing and managing Lance tables by connecting those metadata services or building a custom metadata server in a standardized way. The REST server definition can be found in the OpenAPI specification.</p>"},{"location":"spec/impls/rest/#rest-routes","title":"REST Routes","text":"<p>The REST route for an operation typically follows the pattern of <code>POST /&lt;version&gt;/&lt;object&gt;/{id}/&lt;action&gt;</code>, for example <code>POST /v1/namespace/{id}/list</code> for <code>ListNamespace</code>. The request and response schemas are used as the actual request and response of the route. </p> <p>The key design principle of the REST route is that all the necessary information for a reverse proxy  (e.g. load balancing, authN, authZ) should be available for access without the need to deserialize request body.</p> <p>Because the information could also present in the request body, when the information in the route and  request body does not match, the server must throw a 400 Bad Request error.</p> <p>For routes that involve multiple objects, all related objects should be present in the route. For example, the route for <code>RenameTable</code> is thus <code>POST /v1/table/{id}/rename/to/{id}</code>.</p>"},{"location":"spec/impls/rest/#namespace-server-and-adapter","title":"Namespace Server and Adapter","text":"<p>Any REST HTTP server that implements this OpenAPI protocol is called a Lance Namespace server. If you are a metadata service provider that is building a custom implementation of Lance namespace, building a REST server gives you standardized integration to Lance without the need to worry about tool support and continuously distribute newer library versions compared to using an implementation.</p> <p>If the main purpose of this server is to be a proxy on top of an existing metadata service, converting back and forth between Lance REST API models and native API models of the metadata service, then this Lance namespace server is called a Lance Namespace adapter.</p>"},{"location":"spec/impls/rest/#choosing-between-an-adapter-vs-an-implementation","title":"Choosing between an Adapter vs an Implementation","text":"<p>Any adapter can always be directly a Lance namespace implementation bypassing the REST server, and vise versa. In fact, an implementation is basically the backend of an adapter. For example, we natively support a Lance HMS Namespace implementation, as well as a Lance namespace adapter for HMS by using the HMS Namespace implementation to fulfill requests in the Lance REST server.</p> <p>If you are considering between a Lance namespace adapter vs implementation to build or use in your environment, here are some criteria to consider:</p> <ol> <li>Multi-Language Feasibility &amp; Maintenance Cost: If you want a single strategy that works across all Lance language bindings, an adapter is preferred.    Sometimes it is not even possible for an integration to go with the implementation approach since it cannot support all the languages.    Sometimes an integration is popular or important enough that it is viable to build an implementation and maintain one library per language.</li> <li>Tooling Support: each tool needs to declare the Lance namespace implementations it supports.    That means there will be a preference for tools to always support a REST namespace,    but it might not always support a specific implementation. This favors the adapter approach.</li> <li>Security: if you have security concerns about the adapter being a man-in-the-middle, you should choose an implementation</li> <li>Performance: after all, adapter adds one layer of indirection and is thus not the most performant solution.    If you are performance sensitive, you should choose an implementation</li> </ol>"}]}